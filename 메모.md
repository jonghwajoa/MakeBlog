## ! 연산자와 false

> ! or false 어떤것이 가독성이 더 좋은것인가...?

테스트 코드를 작성하고.. 이를 믿고.. 리팩토링을 하고있다.
그러던중

```js
const subPostValidation = ({ title, content }) => {
  if (!arrayElementIsString([title, content])) {
    return false;
  }

  if (!isLength(title, 1, 100)) {
    return false;
  }
  return true;
};
```

입력값을 검증하는 함수에서 ! 연산자를 쓰고있다. !를 쓰면 편한데.. 이것이 과연 가독성이 좋다고 할 수 있는가..?

```js
const subPostValidation = ({ title, content }) => {
  if (arrayElementIsString([title, content]) === false) {
    return false;
  }

  if (isLength(title, 1, 100) === false) {
    return false;
  }
  return true;
};
```

false 를 사용하면 길어진다는 단점이 있지는 더 명확해 보인다.. (주관적인 생각)
! 연산자를 봤을때 잠시 생각하게 만드는데 false 로 명시하면 아 그렇구나 하고 넘어가게 될 수 있다고 느껴진다..

PS.. 라고 생각했지만.. https://stackoverflow.com/questions/11831881/if-boolean-false-vs-if-boolean
! 이 더 가독성 좋다고 한다.. (그냥 개인선호도 문제)

```js
const subPostValidation = ({ title, content }) => {
  if (!arrayElementIsString([title, content]) || !isLength(title, 1, 100)) {
    return false;
  }
  return true;
};
```

## 함수 표현식 or 함수 선언식

```js
// 함수 선언식
function case1() {
  console.log('case1');
}

// 함수 표현식
case2 = () => {
  console.log('case2');
};
```

어느것이 더 좋다라고 말할 수 없다.
개인의 취향이라한다. 표현식의 경우 호이스팅이 되지 않기 때문에 가독성이 더 좋다고 생각한다.
다만 섞어 쓰지말고 하나만 선택해서 사용하면 된다..

<br>

## 반복적인 요청

Subpage 와 solving 페이지의 content 를 html 전체를 요청하는 것이 아니라 바뀌는 Content 만 JSON 타입으로 요청하여 리소스 소모를 줄이고 새로고침(깜빡거림)을 없앴다.

여기서 든 생각.. 동일한 리소스에 대한 반복적인 요청을 지속적으로 서버에 요청할 필요가 없다고 생각됐다. (서버 부하 줄이기)

한번 받은 리소스 정보를 저장함으로써 부하도 줄이고 반응속도도 향상시켜보자..

### 수정전

<br>

![1](https://user-images.githubusercontent.com/31912670/51841566-51500580-2352-11e9-9ee8-0d5a36c9b506.png)

<br>

![default](https://user-images.githubusercontent.com/31912670/51841674-88261b80-2352-11e9-829e-a62e3c03903f.jpg)

1107 번과 2003 번을 반복적으로 요청하고 있고 매번 서버에 요청을 시도한다.

html 자체를 지속적으로 요구하는 상황이라면 어쩔수 없겠지만..?? JSON 타입만을 요청하고 있는 입장에서 생각해보면..?

> 한번 요청한 리소스에 대해서 저장해보자...
>
> 서버 부하를 최소화하고 응답속도를 빠르게 개선하자..

### post.js

```js
Post.prototype.getContent = async function(postNo, subNo = '1') {
  let result;
  if (this.mapSavePost.has(subNo)) {
    result = this.mapSavePost.get(subNo);
  } else {
    try {
      result = await ajaxUtil.sendGetAjax(`/post/${postNo}/${subNo}`);
      result = JSON.parse(result).post;
    } catch (e) {
      alert(`Server Error(${e.status})`);
      return;
    }
  }
  /* 생략...... */

  if (!this.mapSavePost.has(subNo)) {
    this.mapSavePost.set(subNo, {
      content: content.trim(),
      title: this.postTitle.innerHTML.trim(),
      count: this.viewCount.innerHTML.trim(),
      created_at: this.date.innerHTML.trim(),
    });
  }
};
```

만약 post 에 대한 리소스를 가지고 있다면 요청하지 않고 가지고 있는 리소스로 화면에 표시하게 된다.

리소스가 없을때 서버에 요청하게 되고 Map 에 저장한다.

## Map vs Obejct

문득 든 생각 Map 과 Object 의 차이가 무엇일까..?
Object 자체가 Key,value 의 쌍인데..?

```js
let obj = {};
obj[1] = {
  content: 'content 1입니다.',
  title: 'title 1입니다.',
};

obj[2] = {
  content: 'content 2입니다.',
  title: 'title 2입니다.',
};

console.log(obj);
/*
{ '1': { content: 'content 1입니다.', title: 'title 1입니다.' },
  '2': { content: 'content 2입니다.', title: 'title 2입니다.' } }
*/

console.log(obj[1]);
//  { content: 'content 1입니다.', title: 'title 1입니다.' }

let map = new Map();
map.set(1, {
  content: 'content 1입니다.',
  title: 'title 1입니다.',
});

map.set(2, {
  content: 'content 2입니다.',
  title: 'title 2입니다.',
});

console.log(map);
/*
Map {
  1 => { content: 'content 1입니다.', title: 'title 1입니다.' },
  2 => { content: 'content 2입니다.', title: 'title 2입니다.' } }
*/

console.log(map.get(1));
// { content: 'content 1입니다.', title: 'title 1입니다.' }

```



What is the difference between a map and a dictionary?

모질라에 의하면

> A Map object can iterate its elements in insertion order - a for..of loop will return an array of [key, value] for each iteration.

> Objects are similar to Maps in that both let you set keys to values, retrieve those values, delete keys, and detect whether something is stored at a key. Because of this, Objects have been used as Maps historically; however, there are important differences between Objects and Maps that make using a Map better.
>
> An Object has a prototype, so there are default keys in the map. However, this can be bypassed using map = Object.create(null). The keys of an Object are Strings, where they can be any value for a Map. You can get the size of a Map easily while you have to manually keep track of size for an Object.
>
> Use maps over objects when keys are unknown until run time, and when all keys are the same type and all values are the same type.
>
> Use objects when there is logic that operates on individual elements.

즉

```js
for (let e of obj) {
  console.log(e);
}
// TypeError: obj is not iterable

for (let e of map) {
  console.log(e);
}
/*
[ 1, { content: 'content 1입니다.', title: 'title 1입니다.' } ]
[ 2, { content: 'content 2입니다.', title: 'title 2입니다.' } ]
*/
```



